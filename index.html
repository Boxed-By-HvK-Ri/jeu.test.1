<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Mini Foot Réaliste</title>
<style>
body { margin:0; overflow:hidden; font-family:sans-serif; }
#menu { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
color:white; font-size:28px; background:rgba(0,0,0,0.7); padding:20px; border-radius:10px; text-align:center;}
#menu button { font-size:20px; padding:10px 20px; margin-top:10px; cursor:pointer;}
#scoreboard { position:absolute; top:10px; left:50%; transform:translateX(-50%);
color:white; font-size:24px; background:rgba(0,0,0,0.5); padding:5px 10px; border-radius:5px;}
</style>
</head>
<body>
<div id="menu">
  <div>Mini Foot Réaliste</div>
  <button id="startBtn">Jouer</button>
</div>
<div id="scoreboard" style="display:none;">Équipe A: 0 | Équipe B: 0 | Temps: 0s</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

<script>
// === VARIABLES ===
let scene, camera, renderer;
let player, ball;
let teamA=[], teamB=[];
let keys={}, scoreA=0, scoreB=0, time=0, lastTime=Date.now();
let gameRunning=false;
let ballVelocity=new THREE.Vector3();
const terrainSize={width:30, height:50};
const goalWidth=6, goalHeight=2, goalDepth=1;

// === INIT ===
function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x87CEEB);

  camera=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,20,25);

  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lumière
  const light=new THREE.DirectionalLight(0xffffff,1);
  light.position.set(10,20,10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x404040));

  // Terrain
  const terrain=new THREE.Mesh(
    new THREE.PlaneGeometry(terrainSize.width,terrainSize.height),
    new THREE.MeshPhongMaterial({color:0x228B22})
  );
  terrain.rotation.x=-Math.PI/2;
  scene.add(terrain);

  // Ballon
  const ballGeo=new THREE.SphereGeometry(0.5,32,32);
  const ballMat=new THREE.MeshPhongMaterial({color:0xffffff});
  ball=new THREE.Mesh(ballGeo,ballMat);
  ball.position.y=0.5;
  scene.add(ball);

  // Joueur principal
  const playerGeo=new THREE.BoxGeometry(1,2,1);
  const playerMat=new THREE.MeshPhongMaterial({color:0x0000ff});
  player=new THREE.Mesh(playerGeo,playerMat);
  player.position.set(0,1,10);
  scene.add(player);

  // Coéquipiers IA
  for(let i=0;i<2;i++){
    const teammate=new THREE.Mesh(playerGeo,new THREE.MeshPhongMaterial({color:0x0000ff}));
    teammate.position.set(-5+i*5,1,10);
    scene.add(teammate);
    teamA.push(teammate);
  }

  // Adversaires IA
  for(let i=0;i<3;i++){
    const enemy=new THREE.Mesh(playerGeo,new THREE.MeshPhongMaterial({color:0xff0000}));
    enemy.position.set(-5+i*5,1,-10);
    scene.add(enemy);
    teamB.push(enemy);
  }

  // Buts
  const goalMaterial=new THREE.MeshPhongMaterial({color:0xffff00, opacity:0.6, transparent:true});
  const goalA=new THREE.Mesh(new THREE.BoxGeometry(goalWidth,goalHeight,goalDepth),goalMaterial);
  goalA.position.set(0,goalHeight/2,-terrainSize.height/2);
  scene.add(goalA);
  const goalB=new THREE.Mesh(new THREE.BoxGeometry(goalWidth,goalHeight,goalDepth),goalMaterial);
  goalB.position.set(0,goalHeight/2,terrainSize.height/2);
  scene.add(goalB);

  // Event clavier
  document.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
  document.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

  window.addEventListener('resize',()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
  });
}

// === FONCTIONS ===
function moveAI(player){
  // IA cible le ballon mais avec variation aléatoire pour ne pas tous se coller
  const offsetX = (Math.random()-0.5)*5; 
  const offsetZ = (Math.random()-0.5)*5;
  const dir=new THREE.Vector3(ball.position.x+offsetX-player.position.x,0,ball.position.z+offsetZ-player.position.z);
  dir.clampLength(0,0.05);
  player.position.add(dir);
}

function collide(player){
  const dir=new THREE.Vector3().subVectors(ball.position,player.position);
  if(dir.length()<1.2){ dir.normalize().multiplyScalar(0.2); ballVelocity.add(dir); }
}

function moveBall(){
  ball.position.add(ballVelocity);
  ballVelocity.multiplyScalar(0.95);
  ball.position.y=0.5; // ballon toujours au sol

  // Limites murs invisibles pour le ballon
  const halfWidth=terrainSize.width/2-0.5;
  const halfHeight=terrainSize.height/2-0.5;
  if(ball.position.x<-halfWidth){ball.position.x=-halfWidth; ballVelocity.x*=-0.5;}
  if(ball.position.x>halfWidth){ball.position.x=halfWidth; ballVelocity.x*=-0.5;}
  if(ball.position.z<-halfHeight){ball.position.z=-halfHeight; ballVelocity.z*=-0.5;}
  if(ball.position.z>halfHeight){ball.position.z=halfHeight; ballVelocity.z*=-0.5;}
}

function constrainPlayer(player){
  const halfWidth=terrainSize.width/2-0.5;
  const halfHeight=terrainSize.height/2-0.5;
  if(player.position.x<-halfWidth) player.position.x=-halfWidth;
  if(player.position.x>halfWidth) player.position.x=halfWidth;
  if(player.position.z<-halfHeight) player.position.z=-halfHeight;
  if(player.position.z>halfHeight) player.position.z=halfHeight;
}

// Tir uniquement si proche du ballon
function canShoot(player){
  const dist = player.position.distanceTo(ball.position);
  return dist<2; // frappe possible seulement à très courte distance
}

function checkGoal(){
  // But A
  if(ball.position.z<-terrainSize.height/2+0.5 && Math.abs(ball.position.x)<goalWidth/2){
    scoreB++;
    resetPositions();
  }
  // But B
  if(ball.position.z>terrainSize.height/2-0.5 && Math.abs(ball.position.x)<goalWidth/2){
    scoreA++;
    resetPositions();
  }
  document.getElementById("scoreboard").innerText=`Équipe A: ${scoreA} | Équipe B: ${scoreB} | Temps: ${time}s`;
}

function resetPositions(){
  ball.position.set(0,0.5,0); ballVelocity.set(0,0,0);
  player.position.set(0,1,10);
  teamA[0].position.set(-5,1,10); teamA[1].position.set(5,1,10);
  teamB[0].position.set(-5,1,-10); teamB[1].position.set(0,1,-10); teamB[2].position.set(5,1,-10);
}

// === ANIMATION ===
function animate(){
  if(!gameRunning) return;
  requestAnimationFrame(animate);

  const now=Date.now(); if(now-lastTime>1000){ time++; lastTime=now; }

  // Déplacement joueur principal
  if(keys['z']) player.position.z-=0.2;
  if(keys['s']) player.position.z+=0.2;
  if(keys['q']) player.position.x-=0.2;
  if(keys['d']) player.position.x+=0.2;

  // Tir seulement si proche
  if(keys[' '] && canShoot(player)){
    ballVelocity.z += (player.position.z<ball.position.z ? 0.3 : -0.3);
    ballVelocity.x += (player.position.x<ball.position.x ? 0.1 : -0.1);
  }

  // Contrainte joueur
  constrainPlayer(player);

  // IA
  teamA.forEach(p=>{
    moveAI(p);
    constrainPlayer(p);
    if(canShoot(p)) ballVelocity.add(new THREE.Vector3(0,0,0.2)); // IA tire si proche
  });
  teamB.forEach(p=>{
    moveAI(p);
    constrainPlayer(p);
    if(canShoot(p)) ballVelocity.add(new THREE.Vector3(0,0,-0.2));
  });

  // Collisions
  [...teamA,...teamB,player].forEach(p=>collide(p));

  moveBall();
  checkGoal();

  // Caméra suit joueur
  camera.position.lerp(new THREE.Vector3(player.position.x,20,player.position.z+25),0.05);
  camera.lookAt(player.position);

  renderer.render(scene,camera);
}

// Démarrage
document.getElementById("startBtn").onclick=()=>{
  document.getElementById("menu").style.display="none";
  document.getElementById("scoreboard").style.display="block";
  gameRunning=true;
  init();
  animate();
};
</script>
</body>
</html>
